// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_sessions.sql

package sessiondb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const blockAllUserSessions = `-- name: BlockAllUserSessions :exec
UPDATE user_sessions SET is_blocked = true WHERE user_id = $1::uuid
`

func (q *Queries) BlockAllUserSessions(ctx context.Context, dollar_1 uuid.UUID) error {
	_, err := q.db.Exec(ctx, blockAllUserSessions, dollar_1)
	return err
}

const blockSession = `-- name: BlockSession :exec
UPDATE user_sessions SET is_blocked = true WHERE id = $1::uuid
`

func (q *Queries) BlockSession(ctx context.Context, dollar_1 uuid.UUID) error {
	_, err := q.db.Exec(ctx, blockSession, dollar_1)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO user_sessions (
    user_id,
    ref_token,
    is_blocked,
    client_ip,
    expires_at
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, ref_token, client_ip, is_blocked, expires_at, created_at, updated_at
`

type CreateSessionParams struct {
	UserID    uuid.UUID `db:"user_id"`
	RefToken  string    `db:"ref_token"`
	IsBlocked bool      `db:"is_blocked"`
	ClientIp  string    `db:"client_ip"`
	ExpiresAt time.Time `db:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.RefToken,
		arg.IsBlocked,
		arg.ClientIp,
		arg.ExpiresAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefToken,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM user_sessions WHERE ref_token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, refToken string) error {
	_, err := q.db.Exec(ctx, deleteSession, refToken)
	return err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, user_id, ref_token, client_ip, is_blocked, expires_at, created_at, updated_at FROM user_sessions
WHERE ref_token = $1
  AND is_blocked = false
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetSessionByToken(ctx context.Context, refToken string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, refToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefToken,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionsByUserId = `-- name: GetSessionsByUserId :one
SELECT id, user_id, ref_token, client_ip, is_blocked, expires_at, created_at, updated_at FROM user_sessions
WHERE user_id = $1::uuid
  AND is_blocked = false
  AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetSessionsByUserId(ctx context.Context, dollar_1 uuid.UUID) (UserSession, error) {
	row := q.db.QueryRow(ctx, getSessionsByUserId, dollar_1)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefToken,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
