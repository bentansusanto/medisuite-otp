// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package usersdb

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users(
  name,
  email,
  password,
  phone_number,
  role_id,
  is_verified,
  verify_code,
  verify_expires_at
)VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING
  id,
  name,
  email,
  phone_number,
  role_id,
  is_verified,
  verify_code,
  verify_expires_at,
  created_at,
  updated_at
`

type CreateUserParams struct {
	Name            string    `db:"name"`
	Email           string    `db:"email"`
	Password        string    `db:"password"`
	PhoneNumber     string    `db:"phone_number"`
	RoleID          uuid.UUID `db:"role_id"`
	IsVerified      bool      `db:"is_verified"`
	VerifyCode      string    `db:"verify_code"`
	VerifyExpiresAt time.Time `db:"verify_expires_at"`
}

type CreateUserRow struct {
	ID              uuid.UUID `db:"id"`
	Name            string    `db:"name"`
	Email           string    `db:"email"`
	PhoneNumber     string    `db:"phone_number"`
	RoleID          uuid.UUID `db:"role_id"`
	IsVerified      bool      `db:"is_verified"`
	VerifyCode      string    `db:"verify_code"`
	VerifyExpiresAt time.Time `db:"verify_expires_at"`
	CreatedAt       time.Time `db:"created_at"`
	UpdatedAt       time.Time `db:"updated_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.PhoneNumber,
		arg.RoleID,
		arg.IsVerified,
		arg.VerifyCode,
		arg.VerifyExpiresAt,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.VerifyCode,
		&i.VerifyExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :one
UPDATE users
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, email, password, phone_number, role_id, is_verified, verify_code, verify_expires_at, deleted_at, created_at, updated_at
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.VerifyCode,
		&i.VerifyExpiresAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAllUsers = `-- name: FindAllUsers :many
SELECT
    u.id, u.email, u.name, u.phone_number,
    u.role_id, u.is_verified,
    COALESCE(u.verify_code, '') as verify_code,
    COALESCE(u.verify_expires_at, NOW()) as verify_expires_at,
    u.created_at, u.updated_at,
    r.id as role_id_ref,
    r.name as role_name,
    r.code as role_code,
    r.level as role_level,
    COALESCE(r.description, '') as role_description,
    r.can_self_register as role_can_self_register
FROM users u
JOIN roles r ON u.role_id = r.id
ORDER BY u.created_at DESC
LIMIT $1
`

type FindAllUsersRow struct {
	ID                  uuid.UUID `db:"id"`
	Email               string    `db:"email"`
	Name                string    `db:"name"`
	PhoneNumber         string    `db:"phone_number"`
	RoleID              uuid.UUID `db:"role_id"`
	IsVerified          bool      `db:"is_verified"`
	VerifyCode          string    `db:"verify_code"`
	VerifyExpiresAt     time.Time `db:"verify_expires_at"`
	CreatedAt           time.Time `db:"created_at"`
	UpdatedAt           time.Time `db:"updated_at"`
	RoleIDRef           uuid.UUID `db:"role_id_ref"`
	RoleName            string    `db:"role_name"`
	RoleCode            string    `db:"role_code"`
	RoleLevel           int32     `db:"role_level"`
	RoleDescription     string    `db:"role_description"`
	RoleCanSelfRegister bool      `db:"role_can_self_register"`
}

func (q *Queries) FindAllUsers(ctx context.Context, limit int32) ([]FindAllUsersRow, error) {
	rows, err := q.db.Query(ctx, findAllUsers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllUsersRow
	for rows.Next() {
		var i FindAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.PhoneNumber,
			&i.RoleID,
			&i.IsVerified,
			&i.VerifyCode,
			&i.VerifyExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleIDRef,
			&i.RoleName,
			&i.RoleCode,
			&i.RoleLevel,
			&i.RoleDescription,
			&i.RoleCanSelfRegister,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT
    u.id, u.email, u.password, u.name, u.phone_number,
    u.role_id, u.is_verified, COALESCE(u.verify_code, '') AS verify_code,COALESCE(u.verify_expires_at, NOW()) AS verify_expires_at,u.created_at, u.updated_at,
    r.id as role_id, r.name as role_name, r.code as role_code,
    r.level as role_level, r.description as role_description, r.can_self_register as role_can_self_register
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.email = $1
`

type FindUserByEmailRow struct {
	ID                  uuid.UUID `db:"id"`
	Email               string    `db:"email"`
	Password            string    `db:"password"`
	Name                string    `db:"name"`
	PhoneNumber         string    `db:"phone_number"`
	RoleID              uuid.UUID `db:"role_id"`
	IsVerified          bool      `db:"is_verified"`
	VerifyCode          string    `db:"verify_code"`
	VerifyExpiresAt     time.Time `db:"verify_expires_at"`
	CreatedAt           time.Time `db:"created_at"`
	UpdatedAt           time.Time `db:"updated_at"`
	RoleID_2            uuid.UUID `db:"role_id_2"`
	RoleName            string    `db:"role_name"`
	RoleCode            string    `db:"role_code"`
	RoleLevel           int32     `db:"role_level"`
	RoleDescription     string    `db:"role_description"`
	RoleCanSelfRegister bool      `db:"role_can_self_register"`
}

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (FindUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i FindUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.VerifyCode,
		&i.VerifyExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleID_2,
		&i.RoleName,
		&i.RoleCode,
		&i.RoleLevel,
		&i.RoleDescription,
		&i.RoleCanSelfRegister,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT
	u.id, u.email, u.name, u.phone_number,
	u.role_id, u.is_verified,
	COALESCE(u.verify_code, '') AS verify_code,
	COALESCE(u.verify_expires_at, NOW()) AS verify_expires_at,
	u.created_at, u.updated_at,
	r.id as role_id, r.name as role_name, r.code as role_code,
	r.level as role_level, r.description as role_description, r.can_self_register as role_can_self_register
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.id = $1
`

type FindUserByIdRow struct {
	ID                  uuid.UUID `db:"id"`
	Email               string    `db:"email"`
	Name                string    `db:"name"`
	PhoneNumber         string    `db:"phone_number"`
	RoleID              uuid.UUID `db:"role_id"`
	IsVerified          bool      `db:"is_verified"`
	VerifyCode          string    `db:"verify_code"`
	VerifyExpiresAt     time.Time `db:"verify_expires_at"`
	CreatedAt           time.Time `db:"created_at"`
	UpdatedAt           time.Time `db:"updated_at"`
	RoleID_2            uuid.UUID `db:"role_id_2"`
	RoleName            string    `db:"role_name"`
	RoleCode            string    `db:"role_code"`
	RoleLevel           int32     `db:"role_level"`
	RoleDescription     string    `db:"role_description"`
	RoleCanSelfRegister bool      `db:"role_can_self_register"`
}

func (q *Queries) FindUserById(ctx context.Context, id uuid.UUID) (FindUserByIdRow, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i FindUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.VerifyCode,
		&i.VerifyExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleID_2,
		&i.RoleName,
		&i.RoleCode,
		&i.RoleLevel,
		&i.RoleDescription,
		&i.RoleCanSelfRegister,
	)
	return i, err
}

const findUserByVerifyCode = `-- name: FindUserByVerifyCode :one
SELECT
    u.id, u.email, u.password, u.name, u.phone_number,
    u.role_id, u.is_verified, u.verify_code, u.verify_expires_at,
    u.created_at, u.updated_at,
    r.id as role_id, r.name as role_name, r.code as role_code,
    r.level as role_level, r.description as role_description, r.can_self_register as role_can_self_register
FROM users u
JOIN roles r ON u.role_id = r.id
WHERE u.verify_code = $1
`

type FindUserByVerifyCodeRow struct {
	ID                  uuid.UUID `db:"id"`
	Email               string    `db:"email"`
	Password            string    `db:"password"`
	Name                string    `db:"name"`
	PhoneNumber         string    `db:"phone_number"`
	RoleID              uuid.UUID `db:"role_id"`
	IsVerified          bool      `db:"is_verified"`
	VerifyCode          string    `db:"verify_code"`
	VerifyExpiresAt     time.Time `db:"verify_expires_at"`
	CreatedAt           time.Time `db:"created_at"`
	UpdatedAt           time.Time `db:"updated_at"`
	RoleID_2            uuid.UUID `db:"role_id_2"`
	RoleName            string    `db:"role_name"`
	RoleCode            string    `db:"role_code"`
	RoleLevel           int32     `db:"role_level"`
	RoleDescription     string    `db:"role_description"`
	RoleCanSelfRegister bool      `db:"role_can_self_register"`
}

func (q *Queries) FindUserByVerifyCode(ctx context.Context, verifyCode string) (FindUserByVerifyCodeRow, error) {
	row := q.db.QueryRow(ctx, findUserByVerifyCode, verifyCode)
	var i FindUserByVerifyCodeRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.VerifyCode,
		&i.VerifyExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoleID_2,
		&i.RoleName,
		&i.RoleCode,
		&i.RoleLevel,
		&i.RoleDescription,
		&i.RoleCanSelfRegister,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    name = COALESCE($2, name),
    phone_number = COALESCE($3, phone_number),
    email = COALESCE($4, email),
    password = COALESCE($5, password),
    is_verified = COALESCE($6, is_verified),
    verify_code = $7,
    verify_expires_at = $8,
    updated_at = NOW()
WHERE id = $1
RETURNING
    id,
    name,
    email,
    phone_number,
    role_id,
    is_verified,
    created_at,
    updated_at
`

type UpdateUserParams struct {
	ID              uuid.UUID `db:"id"`
	Name            string    `db:"name"`
	PhoneNumber     string    `db:"phone_number"`
	Email           string    `db:"email"`
	Password        string    `db:"password"`
	IsVerified      bool      `db:"is_verified"`
	VerifyCode      *string    `db:"verify_code"`
	VerifyExpiresAt *time.Time `db:"verify_expires_at"`
}

type UpdateUserRow struct {
	ID          uuid.UUID `db:"id"`
	Name        string    `db:"name"`
	Email       string    `db:"email"`
	PhoneNumber string    `db:"phone_number"`
	RoleID      uuid.UUID `db:"role_id"`
	IsVerified  bool      `db:"is_verified"`
	CreatedAt   time.Time `db:"created_at"`
	UpdatedAt   time.Time `db:"updated_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.PhoneNumber,
		arg.Email,
		arg.Password,
		arg.IsVerified,
		arg.VerifyCode,
		arg.VerifyExpiresAt,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PhoneNumber,
		&i.RoleID,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
